# 运行：
```
cd cmd; go run main.go --config ../test/config.yaml
```

# 代码规范
  dbrainhub项目以分层的方式实现。框架整体分层如下：
  ```
  （1）router 层
  （2）handler 层；
  （3）controller 层；
  （4）logic 层：主要业务逻辑层。
  （5）model 层。
```
  
  其他公共层，所有模块共用：
```
  （1）api 层；http 协议字段；
  （2）errors 层；错误码规范；
  （3）configs 层：全局配置项。
```
  以下分别介绍：
  
  ##### 1.router 层
  router 层用于实现 http server，项目中使用的是 gin。包含了 http 的路由定义、中间件实现等。
  
  ##### 2. handler 层
  handler 层与 router 层是紧密相关的，共同实现 http server 功能。handler层有两个功能：
  1. 实现了 router 层需要的 handler 逻辑，功能上包括：解析参数；调用 controller 层逻辑；发送 http 回应。（比较死板，大多可直接拷贝代码）
  2. 定义了 http 接口的返回规范，包括成功和错误返回。对于失败的场景，区分了三种类型：
  
    （1）请求参数错误：返回码400，返回错误信息；
    （2）未在 errors 模块中定义的错误：返回码500，返回错误信息；
    （3）已在 errors 模块中定义的错误：返回码200， 拷贝 errors 模块中的错误信息。
  
  ##### 3. controller 层
  controller 是一个中介层，对下面业务逻辑层屏蔽了请求来源（http server、grpc server 或者一些脚本），是业务逻辑层的直接调用者。
  其实现逻辑一般包括如下三个方面：
  1. 参数校验；
  2. logic 层功能调用；
  3. 按协议拼接返回值。
  
  ##### 4. logic 层
  logic 是具体的业务逻辑层。理论上，整个项目会被分为多个大的功能，每个大的功能作为一个模块位于单独一个目录中。如 ssh 模块、filebeat 管理模块等。
  由于不同模块可能由不同开发人员开发，为了方便交互，我们可以遵循如下规范：
  1. 每个模块都至少有一个 interface 文件，里面包含了本模块提供功能以及结构体定义（依赖倒置：实现类和外部模块都只依赖接口）；
  2. 每个 interface 需要提供一个 New函数/factory结构，方便使用本模块的接口。本模块内定义的 Impl 实现类对外部模块完全不可见；
  3. 至于模块内功能如何实现，不做要求。但为了方便单测以及后期维护，最好也进行子模块拆分，不同子模块使用接口交互（不过这些子模块接口及其实现对外部模块不可见）。
  
  关于 logic 层中结构体的定义。每个模块只定义出自己真正需要的以及可以直接返回的结构，无需对参数和返回值进行特殊处理（controller 负责处理），不应该受 http 参数、数据库表定义等的影响。
  
  ##### 5. model 层
  model 负责实现数据库相关逻辑。尽量遵循如下规范：
  1. 每个 go 文件对应一个表，文件名与表名保持一致，都用单数形式，该文件中包含了表的结构体定义以及对此表的操作；
  2. 由于 model 层被 logic 层所有模块依赖，所以抽象出的接口尽量满足普适性，复杂逻辑放到 logic 中实现。
  
  model 层不依赖于 logic 层，所以如果表结构体定义为 A，那么 model 层返回出去的结果就是 *A 或者 []*A，与 logic 层的结构无关。
  
  ##### 6. api 层
  api 层以 protobuf 规范定义了 http 的接口协议。当存在新增接口时，使用 proto 命令重新生成 pb.go 文件。使用 proto 文件，考虑如下三个原因：
  1. 方便阅读。相比 go 里的结构体，可读性、通用性更好；
  2. 可用于生成 http handler 层代码：待升级；
  3. 方便生成 swagger 文档：待升级。
  
  proto 生成命令：
  ```
protoc  -I ./ --proto_path=../ --go_out=../ ./http.proto
  ```
  
  ##### 7. errors 层
  errors 中以一定的规范定义了 logic 层中出现的错误。logic 层中返回的错误应该都是从 errors 中拿到的，而非通过`fmt.Errorf`创建。
  
  handler 层在发送 http 响应时，会检查 error 是否为 errors 层中定义的，如果不是，说明发生了未知错误，会返回错误码500回去。